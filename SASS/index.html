<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SASS</title>
        <link rel="stylesheet" href="style/style.css">
    </head>
    <body>
        <article>
            <section>
                <h1>SASS</h1>
                <p>Pre processador que facilita e muito a escrita de arquivos css com uma sintaxe bem elaborada, com variáveis, loops, condicionais. funções, mixins (muito importante)</p>
                <p>Com o SASS podemos escrever tanto em SASS quanto SCSS, está ultima mais utilizada pois se parece mais com o próprio CSS.</p>
            </section>
            <section>
                <h1>Criando o arquivo</h1>
                <p>Para criação do arquivo, basta adicionar a extensão .sass ou .scss e usarmos a sintaxe</p>
                <p>Porem o navegador lê apenas arquivos CSS, então devemos sempre compilar o arquivo .scss para CSS</p>
                <p>Para que o próprio SASS gere o arquivo CSS quando modificamos o arquivo SCSS, é bem simples, basta adicionar o seguinte comando ao terminal: </p>
                <p>sass --watch arquivo-origem.scss:arquivo-destino.css</p>
                <p>Que para cada mudança no arquivo, o próprio SASS irá compilar para o CSS, podemos tambem utilizar o mesmo comando para monitorar pastas inteiras com varios arquivos SCSS param serem compilados CSS</p>
                <p>sass --watch pasta-origem:pasta-destino</p>
                <h4>Tipos de saída</h4>
                <p>Temos como definir o estilo de saída do CSS com a flag --style estilo sendo eles:</p>
                <p>--style nested - que aninha os elementos, quase nenhum diferença, apenas na indentação</p>
                <p>--style expanded - respeita os espaços e pula linha entre as regras do arquivo salvo</p>
                <p>--style compact - as propriedades ficam todas na mesma linha</p>
                <p>--style compressed - minifica o arquivo de saída CSS</p>
                <h4>Comentários</h4>
                <p>Para comentar os arquivos SASS  é utilizado a mesma sintaxe do CSS /* Comentário */</p>
                <p>
                    Será gerado no arquivo CSS e exibido normalmente, mas para os casos  em que usamos outputs minificados para o scss (--style compressed) a sessão comentada desaparece, para resolver isto basta adicionar um ! logo após o /*
                </p>
                <p>Ficando /*! Comentário */</p>
                <p> E para que o comentário não apareça no arquivo CSS gerado, basta comentar com // Comentário</p>
                <h4>Aninhamento</h4>
                <p>Com o SASS para escrita de CSS em que usamos seletores descendentes ( div p { }), podemos realizar a escrita de forma aninhada</p>
                <p>.minhaclasse {</p>
                <p>propriedade: valor;</p>
                <p>elemento-descendente {</p>
                <p>propriedade: valor;</p>
                <p>}</p>
                <p>}</p>
                <p>Que o CSS gerado será separado colocando os elementos descendentes de acordo com a sintaxe CSS</p>
                <p>Dentro do aninhamento, não precisamos escrever novamente os seletores pai, basta adicionar &:hover por exemplo</p>
                <h4>Interpolação</h4>
                <p>Comparável ao eval do JS, a interpolação, transforma sempre irá exibir o conteúdo da variável e não o seu nome em certos casos. #{$variável}</p>
                <h4>Namespace</h4>
                <p>Quando temos propriedades como o font, onde temos, size, weight, family, etc. Para evitar declarar como o CSS comum onde nomeados cada item, podemos criar algo semelhante a:</p>
                <p>font:{</p>
                <p>size: 10px;</p>
                <p>weight: bold;</p>
                <p>family: 'Arial';</p>
                <p>}</p>
                <h4>Variáveis</h4>
                <p>Podemos declarar variáveis em SASS usando $nome-da-variavel, assim como qualquer linguagem, a variável respeita o escopo em que é gerada</p>
                <p>Devemos evitar utilizar nomes muito específicos como cores $red: red; quando quisermos mudar a cor, teremos que mexer em toda a estrutura pois, utilizamos o nome red e em outra cor dificultara a a leitura do código, devemos utilizar nomes mais globais como, $primary-color: blue;</p>
                <h4>Terminal SASS</h4>
                <p>Podemos interagir com o SASS através do próprio terminal, para criação de variáveis e cálculos com cores etc, basta digitar: </p>
                <p>sass -i</p>
                <h4>Tipos de dados</h4>
                <p>Podemos armazenar em variaveis, os seguintes tipos de dados:</p>
                <p>$variavel: 'string'; que armazena textos</p>
                <p>$variavel: 10; números, que representa quantidade e podendo ter medidas (px, em, etc.</p>
                <p>$variavel: #FFF; cores em qualquer </p>
                <p>$variavel: boolean; true ou false</p>
                <p>$variavel: '10px 10px, 25px 25px'; que armazena textos</p>
                <p>$variavel: ('key1': value1, 'key2': value2); que se comportam basicamente como literals do js, recebendo chave e valor, para resgatar o valor informamos map-get($mapa, chave1)</p>
                <p>Para identificarmos o tipo da váriavel podemos utilizar type-of($variavel)</p>
                <h4>Imports</h4>
                <p>Com a sintaxe @import, podemos importar e utilizar outros arquivos scss, css e urls dentro do nosso arquivo</p>
                <p>@import 'variaveis.scss';</p>
                <p>@import url('https://fonts.googleapis.com/css?family=Roboto');<p>
                <h4>Uses</h4>
                <p>Devido a problemas com os imports, a equipe do sass recomenda atualmente o uso de @use, basicamente faz a mesma função, mas com limitações de escopo</p>
                <p>Basta usar @use "src/variaveis"</p>
                <p>functions, mixins e variaveis recebem o namespace do module que foi importado, como variaveis.nome-da-variavel na declaração.</p>
                <h4>Partials</h4>
                <p>Partials são arquivos parciais de SCSS, ou seja, um scss com mixins, um scss com as variaveis, etc, declaramos um partial com um _ antes do nome, ex: _mixins.scss</p>
                <p>A vantagem é que ao ser importado no código principal, eles são ignorados e não geram arquivos CSS separados.</p>
                <h4>Mixins</h4>
                <p>Outro item extremamente importante do SASS são os mixins, conjuntos de códigos de estilo pre definidos que para usar em uma regra basta adicionar @include, que o SASS trata de repassar as informações corretamente </p>
                <p>Temos o mixin sem parâmetros que retorna apenas os dados informados @mixin colorir { propriedade: valor; propriedade: valor; }</p>
                <p>Temos o mixin com parâmetros que é bastante utilizados pois deixa ainda mais versátil @mixin colorir (parametro, parametro) {propriedade: parametro, propriedade: parametro;</p>
                <p>Temos o mixin com parâmetros e valores default, caso o parâmetro não seja informado terá um valor padrão, sempre valores default devem estar no ultimo item do parametro @mixin colorir (parametro, parametro: valor) {propriedade: parametro, propriedade: parametro;</p>
                <p>Temos o mixin com parâmetros infinitos, retornando uma lista assim como o operador rest do JS, @mixin colorir, tambem deve ser sempre o ultimo elemento(parametros...) {propriedade: parametro, propriedade: parametro;</p>
                <h4>Extends</h4>
                <p>@extend é como o do JS em POO, ele estende a classe pai adicionando as usas propriedades.</p>
                <h5>Mixin ou Extend?</h5>
                <p>Como ambos são bem parecidos, devemos utilizar mixins quando recebemos parametros, e extend para deixar o código semântico, quando herdo propriedades entre classes ligadas, caso contrario tambem podemos utilizar mixin. </p>
                <p>Operações com números</p>
                <p>Os operadores são os aritméticos e relacionais como os de JS</p>
                <p>Salves algumas observações: 1-) Não podemos fazer operações com medidas diferentes. 2-)Não podemos fazer divisão fora dos parenteses (20px / 4); 3-) Não devemos multiplicar os números pelas próprias medidas ex: 20px * 20px, devemos utilizar o multiplicador apenas número, ex 20px * 20  </p>
                <h4>Operadores com cores</h4>
                <p>Podemos usar com cores alguns operadores aritméticos como +, - e *, atenção que para cores rgba, o alpha deve sempre ser o mesmo</p>
                
                <h4>Operadores com string</h4>
                <p>Para string temos apenas o + que serve para concatena-las</p>
                <h4>Diretivas de controle</h4>
                <p>Assim como em linguagens de programação, temos @if, @else e @else if, @each e @while</p>
                <p>O @if se comporta exatamente como em JS @if (condição) { código }</p>
                <p>O @each seria como o forEach de arrays, pega listas e itera sobre cada item @each $item in @lista {font-size: item;} </p>
                <p>O @for é exatamente como for de JS @for $i from 1 through 3 {código} </p>
                <p>O @while tambem é exatamente como em JS, @while condição { código }</p>
                <h4>Funções</h4>
                <p>As @function, tambem funcionam igualmente em JS, porem deve sempre terem um return:</p>
                <h4>Funções nativas</p>
                <h5>Funções nativas para cores:</h4>
                <p>darken(cor, percentagem), pare escurecer uma cor</p>
                <p>lighten(cor, percentagem), pare clarear uma cor</p>
                <p>saturate(cor, percentagem), pare aumentar a saturação de uma cor</p>
                <p>desaturate(cor, percentagem), pare diminuir a saturação de uma cor</p>
                <p>adjust-hue(cor, percentagem), aumenta ou diminui a tonaldade de uma cor</p>
                <p>hls(grau-da-cor, sautração-%<, brilho-%; função para escrever cores através do hls</p>
                <p>complement(cor); identifica o complemento de uma cor</p>
                <p>invert(cor); identifica a cor inversa de uma cor</p>
                <p>alpha(cor); retorna o alpha de uma cor</p>
                <p>opacify(cor, valor) ou fade-in(cor, valor); retorna a cor mais opaca</p>
                <p>transparentize(cor, valor) ou fade-out(cor, valor); retorna a cor mais transparente</p>
                <h5>Funções nativas para strings:</h4>
                <p>unquote(string) e quote(string), remove e adiciona aspas respectivamente</p>
                <p>str-length(string), retorna o tamanho da string</p>
                <p>to-upper-case(string) e to-lower-case(string), transforma a string em maiúscula ou minúscula respectivamente</p>
                <h5>Funções nativas para números:</h4>
                <p>percentage(número), retorna a percentagem do número</p>
                <p>roud(número), arredonda o número</p>
                <p>ceil(número), sempre arredondará o número para cima</p>
                <p>floor(número), sempre arredondará o número para baixo</p>
                <p>min(números) e max(números), retorna o menor e o maior valor de um número respectivamente</p>
                <p>random(limite)</p>
                <h5>Funções nativas para listas(arrays)</h5>
                <p>length($lista); retorna o tamanho da lista</p>
                <p>nth(lista, posição); retorna a posição do item.</p>
                <p>set-nth(lista, posição); retorna a posição do item.</p>
                <h5>Funções nativas para listas(arrays)</h5>
                <p>map-get(mapa, chave) retorna o valor da chave passada no parâmetro</p>
                <p>map-merge(mapa1, mapa2) retorna retorna um novo mapa a partir da junção dos dois passados no parâmetro</p>
                <p>map-remove(mapa, chave)s remove as chaves informadas</p>
            </section>
            <section>

            </section>
        </article>
    </body>
</html>